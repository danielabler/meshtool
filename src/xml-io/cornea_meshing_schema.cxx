// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "cornea_meshing_schema.hxx"

// ZernikeCoefficientType
// 

const ZernikeCoefficientType::n_type& ZernikeCoefficientType::
n () const
{
  return this->n_.get ();
}

ZernikeCoefficientType::n_type& ZernikeCoefficientType::
n ()
{
  return this->n_.get ();
}

void ZernikeCoefficientType::
n (const n_type& x)
{
  this->n_.set (x);
}

const ZernikeCoefficientType::m_type& ZernikeCoefficientType::
m () const
{
  return this->m_.get ();
}

ZernikeCoefficientType::m_type& ZernikeCoefficientType::
m ()
{
  return this->m_.get ();
}

void ZernikeCoefficientType::
m (const m_type& x)
{
  this->m_.set (x);
}


// ZernikeCoefficientType_single_index
// 

const ZernikeCoefficientType_single_index::j_type& ZernikeCoefficientType_single_index::
j () const
{
  return this->j_.get ();
}

ZernikeCoefficientType_single_index::j_type& ZernikeCoefficientType_single_index::
j ()
{
  return this->j_.get ();
}

void ZernikeCoefficientType_single_index::
j (const j_type& x)
{
  this->j_.set (x);
}


// ZernikeSurfaceType
// 

const ZernikeSurfaceType::ZernikeCoefficient_sequence& ZernikeSurfaceType::
ZernikeCoefficient () const
{
  return this->ZernikeCoefficient_;
}

ZernikeSurfaceType::ZernikeCoefficient_sequence& ZernikeSurfaceType::
ZernikeCoefficient ()
{
  return this->ZernikeCoefficient_;
}

void ZernikeSurfaceType::
ZernikeCoefficient (const ZernikeCoefficient_sequence& s)
{
  this->ZernikeCoefficient_ = s;
}

const ZernikeSurfaceType::ZernikeCoefficientSingleIndex_sequence& ZernikeSurfaceType::
ZernikeCoefficientSingleIndex () const
{
  return this->ZernikeCoefficientSingleIndex_;
}

ZernikeSurfaceType::ZernikeCoefficientSingleIndex_sequence& ZernikeSurfaceType::
ZernikeCoefficientSingleIndex ()
{
  return this->ZernikeCoefficientSingleIndex_;
}

void ZernikeSurfaceType::
ZernikeCoefficientSingleIndex (const ZernikeCoefficientSingleIndex_sequence& s)
{
  this->ZernikeCoefficientSingleIndex_ = s;
}


// MeshCriteriaGlobalType
// 

const MeshCriteriaGlobalType::facet_angle_type& MeshCriteriaGlobalType::
facet_angle () const
{
  return this->facet_angle_.get ();
}

MeshCriteriaGlobalType::facet_angle_type& MeshCriteriaGlobalType::
facet_angle ()
{
  return this->facet_angle_.get ();
}

void MeshCriteriaGlobalType::
facet_angle (const facet_angle_type& x)
{
  this->facet_angle_.set (x);
}

const MeshCriteriaGlobalType::facet_size_type& MeshCriteriaGlobalType::
facet_size () const
{
  return this->facet_size_.get ();
}

MeshCriteriaGlobalType::facet_size_type& MeshCriteriaGlobalType::
facet_size ()
{
  return this->facet_size_.get ();
}

void MeshCriteriaGlobalType::
facet_size (const facet_size_type& x)
{
  this->facet_size_.set (x);
}

const MeshCriteriaGlobalType::facet_distance_type& MeshCriteriaGlobalType::
facet_distance () const
{
  return this->facet_distance_.get ();
}

MeshCriteriaGlobalType::facet_distance_type& MeshCriteriaGlobalType::
facet_distance ()
{
  return this->facet_distance_.get ();
}

void MeshCriteriaGlobalType::
facet_distance (const facet_distance_type& x)
{
  this->facet_distance_.set (x);
}

const MeshCriteriaGlobalType::cell_radius_edge_ratio_type& MeshCriteriaGlobalType::
cell_radius_edge_ratio () const
{
  return this->cell_radius_edge_ratio_.get ();
}

MeshCriteriaGlobalType::cell_radius_edge_ratio_type& MeshCriteriaGlobalType::
cell_radius_edge_ratio ()
{
  return this->cell_radius_edge_ratio_.get ();
}

void MeshCriteriaGlobalType::
cell_radius_edge_ratio (const cell_radius_edge_ratio_type& x)
{
  this->cell_radius_edge_ratio_.set (x);
}

const MeshCriteriaGlobalType::cell_size_type& MeshCriteriaGlobalType::
cell_size () const
{
  return this->cell_size_.get ();
}

MeshCriteriaGlobalType::cell_size_type& MeshCriteriaGlobalType::
cell_size ()
{
  return this->cell_size_.get ();
}

void MeshCriteriaGlobalType::
cell_size (const cell_size_type& x)
{
  this->cell_size_.set (x);
}


// CorneaGenerationCriteriaGlobalType
// 

const CorneaGenerationCriteriaGlobalType::max_number_zernike_coeffs_type& CorneaGenerationCriteriaGlobalType::
max_number_zernike_coeffs () const
{
  return this->max_number_zernike_coeffs_.get ();
}

CorneaGenerationCriteriaGlobalType::max_number_zernike_coeffs_type& CorneaGenerationCriteriaGlobalType::
max_number_zernike_coeffs ()
{
  return this->max_number_zernike_coeffs_.get ();
}

void CorneaGenerationCriteriaGlobalType::
max_number_zernike_coeffs (const max_number_zernike_coeffs_type& x)
{
  this->max_number_zernike_coeffs_.set (x);
}

const CorneaGenerationCriteriaGlobalType::surface_thickness_type& CorneaGenerationCriteriaGlobalType::
surface_thickness () const
{
  return this->surface_thickness_.get ();
}

CorneaGenerationCriteriaGlobalType::surface_thickness_type& CorneaGenerationCriteriaGlobalType::
surface_thickness ()
{
  return this->surface_thickness_.get ();
}

void CorneaGenerationCriteriaGlobalType::
surface_thickness (const surface_thickness_type& x)
{
  this->surface_thickness_.set (x);
}

const CorneaGenerationCriteriaGlobalType::offset_along_z_type& CorneaGenerationCriteriaGlobalType::
offset_along_z () const
{
  return this->offset_along_z_.get ();
}

CorneaGenerationCriteriaGlobalType::offset_along_z_type& CorneaGenerationCriteriaGlobalType::
offset_along_z ()
{
  return this->offset_along_z_.get ();
}

void CorneaGenerationCriteriaGlobalType::
offset_along_z (const offset_along_z_type& x)
{
  this->offset_along_z_.set (x);
}

const CorneaGenerationCriteriaGlobalType::path_to_output_type& CorneaGenerationCriteriaGlobalType::
path_to_output () const
{
  return this->path_to_output_.get ();
}

CorneaGenerationCriteriaGlobalType::path_to_output_type& CorneaGenerationCriteriaGlobalType::
path_to_output ()
{
  return this->path_to_output_.get ();
}

void CorneaGenerationCriteriaGlobalType::
path_to_output (const path_to_output_type& x)
{
  this->path_to_output_.set (x);
}

void CorneaGenerationCriteriaGlobalType::
path_to_output (::std::auto_ptr< path_to_output_type > x)
{
  this->path_to_output_.set (x);
}


// LenticuleGenerationCriteriaGlobalType
// 

const LenticuleGenerationCriteriaGlobalType::max_number_zernike_coeffs_type& LenticuleGenerationCriteriaGlobalType::
max_number_zernike_coeffs () const
{
  return this->max_number_zernike_coeffs_.get ();
}

LenticuleGenerationCriteriaGlobalType::max_number_zernike_coeffs_type& LenticuleGenerationCriteriaGlobalType::
max_number_zernike_coeffs ()
{
  return this->max_number_zernike_coeffs_.get ();
}

void LenticuleGenerationCriteriaGlobalType::
max_number_zernike_coeffs (const max_number_zernike_coeffs_type& x)
{
  this->max_number_zernike_coeffs_.set (x);
}

const LenticuleGenerationCriteriaGlobalType::lenticule_radius_type& LenticuleGenerationCriteriaGlobalType::
lenticule_radius () const
{
  return this->lenticule_radius_.get ();
}

LenticuleGenerationCriteriaGlobalType::lenticule_radius_type& LenticuleGenerationCriteriaGlobalType::
lenticule_radius ()
{
  return this->lenticule_radius_.get ();
}

void LenticuleGenerationCriteriaGlobalType::
lenticule_radius (const lenticule_radius_type& x)
{
  this->lenticule_radius_.set (x);
}

const LenticuleGenerationCriteriaGlobalType::cap_thickness_type& LenticuleGenerationCriteriaGlobalType::
cap_thickness () const
{
  return this->cap_thickness_.get ();
}

LenticuleGenerationCriteriaGlobalType::cap_thickness_type& LenticuleGenerationCriteriaGlobalType::
cap_thickness ()
{
  return this->cap_thickness_.get ();
}

void LenticuleGenerationCriteriaGlobalType::
cap_thickness (const cap_thickness_type& x)
{
  this->cap_thickness_.set (x);
}

const LenticuleGenerationCriteriaGlobalType::lenticule_thickness_type& LenticuleGenerationCriteriaGlobalType::
lenticule_thickness () const
{
  return this->lenticule_thickness_.get ();
}

LenticuleGenerationCriteriaGlobalType::lenticule_thickness_type& LenticuleGenerationCriteriaGlobalType::
lenticule_thickness ()
{
  return this->lenticule_thickness_.get ();
}

void LenticuleGenerationCriteriaGlobalType::
lenticule_thickness (const lenticule_thickness_type& x)
{
  this->lenticule_thickness_.set (x);
}

const LenticuleGenerationCriteriaGlobalType::lenticule_surface_distance_type& LenticuleGenerationCriteriaGlobalType::
lenticule_surface_distance () const
{
  return this->lenticule_surface_distance_.get ();
}

LenticuleGenerationCriteriaGlobalType::lenticule_surface_distance_type& LenticuleGenerationCriteriaGlobalType::
lenticule_surface_distance ()
{
  return this->lenticule_surface_distance_.get ();
}

void LenticuleGenerationCriteriaGlobalType::
lenticule_surface_distance (const lenticule_surface_distance_type& x)
{
  this->lenticule_surface_distance_.set (x);
}


// ConeBoundaryType
// 

const ConeBoundaryType::angle_type& ConeBoundaryType::
angle () const
{
  return this->angle_.get ();
}

ConeBoundaryType::angle_type& ConeBoundaryType::
angle ()
{
  return this->angle_.get ();
}

void ConeBoundaryType::
angle (const angle_type& x)
{
  this->angle_.set (x);
}


// CylinderBoundaryType
// 

const CylinderBoundaryType::radius_type& CylinderBoundaryType::
radius () const
{
  return this->radius_.get ();
}

CylinderBoundaryType::radius_type& CylinderBoundaryType::
radius ()
{
  return this->radius_.get ();
}

void CylinderBoundaryType::
radius (const radius_type& x)
{
  this->radius_.set (x);
}


// CorneaBoundaryType
// 

const CorneaBoundaryType::Cone_optional& CorneaBoundaryType::
Cone () const
{
  return this->Cone_;
}

CorneaBoundaryType::Cone_optional& CorneaBoundaryType::
Cone ()
{
  return this->Cone_;
}

void CorneaBoundaryType::
Cone (const Cone_type& x)
{
  this->Cone_.set (x);
}

void CorneaBoundaryType::
Cone (const Cone_optional& x)
{
  this->Cone_ = x;
}

void CorneaBoundaryType::
Cone (::std::auto_ptr< Cone_type > x)
{
  this->Cone_.set (x);
}

const CorneaBoundaryType::Cylinder_optional& CorneaBoundaryType::
Cylinder () const
{
  return this->Cylinder_;
}

CorneaBoundaryType::Cylinder_optional& CorneaBoundaryType::
Cylinder ()
{
  return this->Cylinder_;
}

void CorneaBoundaryType::
Cylinder (const Cylinder_type& x)
{
  this->Cylinder_.set (x);
}

void CorneaBoundaryType::
Cylinder (const Cylinder_optional& x)
{
  this->Cylinder_ = x;
}

void CorneaBoundaryType::
Cylinder (::std::auto_ptr< Cylinder_type > x)
{
  this->Cylinder_.set (x);
}


// CorneaMeshingParametersType
// 

const CorneaMeshingParametersType::AnteriorSurface_type& CorneaMeshingParametersType::
AnteriorSurface () const
{
  return this->AnteriorSurface_.get ();
}

CorneaMeshingParametersType::AnteriorSurface_type& CorneaMeshingParametersType::
AnteriorSurface ()
{
  return this->AnteriorSurface_.get ();
}

void CorneaMeshingParametersType::
AnteriorSurface (const AnteriorSurface_type& x)
{
  this->AnteriorSurface_.set (x);
}

void CorneaMeshingParametersType::
AnteriorSurface (::std::auto_ptr< AnteriorSurface_type > x)
{
  this->AnteriorSurface_.set (x);
}

const CorneaMeshingParametersType::PosteriorSurface_type& CorneaMeshingParametersType::
PosteriorSurface () const
{
  return this->PosteriorSurface_.get ();
}

CorneaMeshingParametersType::PosteriorSurface_type& CorneaMeshingParametersType::
PosteriorSurface ()
{
  return this->PosteriorSurface_.get ();
}

void CorneaMeshingParametersType::
PosteriorSurface (const PosteriorSurface_type& x)
{
  this->PosteriorSurface_.set (x);
}

void CorneaMeshingParametersType::
PosteriorSurface (::std::auto_ptr< PosteriorSurface_type > x)
{
  this->PosteriorSurface_.set (x);
}

const CorneaMeshingParametersType::PosteriorSurfaceLenticule_optional& CorneaMeshingParametersType::
PosteriorSurfaceLenticule () const
{
  return this->PosteriorSurfaceLenticule_;
}

CorneaMeshingParametersType::PosteriorSurfaceLenticule_optional& CorneaMeshingParametersType::
PosteriorSurfaceLenticule ()
{
  return this->PosteriorSurfaceLenticule_;
}

void CorneaMeshingParametersType::
PosteriorSurfaceLenticule (const PosteriorSurfaceLenticule_type& x)
{
  this->PosteriorSurfaceLenticule_.set (x);
}

void CorneaMeshingParametersType::
PosteriorSurfaceLenticule (const PosteriorSurfaceLenticule_optional& x)
{
  this->PosteriorSurfaceLenticule_ = x;
}

void CorneaMeshingParametersType::
PosteriorSurfaceLenticule (::std::auto_ptr< PosteriorSurfaceLenticule_type > x)
{
  this->PosteriorSurfaceLenticule_.set (x);
}

const CorneaMeshingParametersType::PupilRadius_type& CorneaMeshingParametersType::
PupilRadius () const
{
  return this->PupilRadius_.get ();
}

CorneaMeshingParametersType::PupilRadius_type& CorneaMeshingParametersType::
PupilRadius ()
{
  return this->PupilRadius_.get ();
}

void CorneaMeshingParametersType::
PupilRadius (const PupilRadius_type& x)
{
  this->PupilRadius_.set (x);
}

const CorneaMeshingParametersType::SurfaceDistance_type& CorneaMeshingParametersType::
SurfaceDistance () const
{
  return this->SurfaceDistance_.get ();
}

CorneaMeshingParametersType::SurfaceDistance_type& CorneaMeshingParametersType::
SurfaceDistance ()
{
  return this->SurfaceDistance_.get ();
}

void CorneaMeshingParametersType::
SurfaceDistance (const SurfaceDistance_type& x)
{
  this->SurfaceDistance_.set (x);
}

const CorneaMeshingParametersType::MeshCriteria_type& CorneaMeshingParametersType::
MeshCriteria () const
{
  return this->MeshCriteria_.get ();
}

CorneaMeshingParametersType::MeshCriteria_type& CorneaMeshingParametersType::
MeshCriteria ()
{
  return this->MeshCriteria_.get ();
}

void CorneaMeshingParametersType::
MeshCriteria (const MeshCriteria_type& x)
{
  this->MeshCriteria_.set (x);
}

void CorneaMeshingParametersType::
MeshCriteria (::std::auto_ptr< MeshCriteria_type > x)
{
  this->MeshCriteria_.set (x);
}

const CorneaMeshingParametersType::CorneaGenerationCriteria_type& CorneaMeshingParametersType::
CorneaGenerationCriteria () const
{
  return this->CorneaGenerationCriteria_.get ();
}

CorneaMeshingParametersType::CorneaGenerationCriteria_type& CorneaMeshingParametersType::
CorneaGenerationCriteria ()
{
  return this->CorneaGenerationCriteria_.get ();
}

void CorneaMeshingParametersType::
CorneaGenerationCriteria (const CorneaGenerationCriteria_type& x)
{
  this->CorneaGenerationCriteria_.set (x);
}

void CorneaMeshingParametersType::
CorneaGenerationCriteria (::std::auto_ptr< CorneaGenerationCriteria_type > x)
{
  this->CorneaGenerationCriteria_.set (x);
}

const CorneaMeshingParametersType::LenticuleGenerationCriteria_optional& CorneaMeshingParametersType::
LenticuleGenerationCriteria () const
{
  return this->LenticuleGenerationCriteria_;
}

CorneaMeshingParametersType::LenticuleGenerationCriteria_optional& CorneaMeshingParametersType::
LenticuleGenerationCriteria ()
{
  return this->LenticuleGenerationCriteria_;
}

void CorneaMeshingParametersType::
LenticuleGenerationCriteria (const LenticuleGenerationCriteria_type& x)
{
  this->LenticuleGenerationCriteria_.set (x);
}

void CorneaMeshingParametersType::
LenticuleGenerationCriteria (const LenticuleGenerationCriteria_optional& x)
{
  this->LenticuleGenerationCriteria_ = x;
}

void CorneaMeshingParametersType::
LenticuleGenerationCriteria (::std::auto_ptr< LenticuleGenerationCriteria_type > x)
{
  this->LenticuleGenerationCriteria_.set (x);
}

const CorneaMeshingParametersType::CorneaBoundary_type& CorneaMeshingParametersType::
CorneaBoundary () const
{
  return this->CorneaBoundary_.get ();
}

CorneaMeshingParametersType::CorneaBoundary_type& CorneaMeshingParametersType::
CorneaBoundary ()
{
  return this->CorneaBoundary_.get ();
}

void CorneaMeshingParametersType::
CorneaBoundary (const CorneaBoundary_type& x)
{
  this->CorneaBoundary_.set (x);
}

void CorneaMeshingParametersType::
CorneaBoundary (::std::auto_ptr< CorneaBoundary_type > x)
{
  this->CorneaBoundary_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// ZernikeCoefficientType
//

ZernikeCoefficientType::
ZernikeCoefficientType (const ::xml_schema::float_& _xsd_float__base,
                        const n_type& n,
                        const m_type& m)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  n_ (n, this),
  m_ (m, this)
{
}

ZernikeCoefficientType::
ZernikeCoefficientType (const ZernikeCoefficientType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  n_ (x.n_, f, this),
  m_ (x.m_, f, this)
{
}

ZernikeCoefficientType::
ZernikeCoefficientType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  n_ (this),
  m_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ZernikeCoefficientType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "n" && n.namespace_ ().empty ())
    {
      this->n_.set (n_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "m" && n.namespace_ ().empty ())
    {
      this->m_.set (m_traits::create (i, f, this));
      continue;
    }
  }

  if (!n_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "n",
      "");
  }

  if (!m_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "m",
      "");
  }
}

ZernikeCoefficientType* ZernikeCoefficientType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ZernikeCoefficientType (*this, f, c);
}

ZernikeCoefficientType& ZernikeCoefficientType::
operator= (const ZernikeCoefficientType& x)
{
  if (this != &x)
  {
    static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (*this) = x;
    this->n_ = x.n_;
    this->m_ = x.m_;
  }

  return *this;
}

ZernikeCoefficientType::
~ZernikeCoefficientType ()
{
}

// ZernikeCoefficientType_single_index
//

ZernikeCoefficientType_single_index::
ZernikeCoefficientType_single_index (const ::xml_schema::float_& _xsd_float__base,
                                     const j_type& j)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base),
  j_ (j, this)
{
}

ZernikeCoefficientType_single_index::
ZernikeCoefficientType_single_index (const ZernikeCoefficientType_single_index& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c),
  j_ (x.j_, f, this)
{
}

ZernikeCoefficientType_single_index::
ZernikeCoefficientType_single_index (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
  j_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ZernikeCoefficientType_single_index::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "j" && n.namespace_ ().empty ())
    {
      this->j_.set (j_traits::create (i, f, this));
      continue;
    }
  }

  if (!j_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "j",
      "");
  }
}

ZernikeCoefficientType_single_index* ZernikeCoefficientType_single_index::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ZernikeCoefficientType_single_index (*this, f, c);
}

ZernikeCoefficientType_single_index& ZernikeCoefficientType_single_index::
operator= (const ZernikeCoefficientType_single_index& x)
{
  if (this != &x)
  {
    static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (*this) = x;
    this->j_ = x.j_;
  }

  return *this;
}

ZernikeCoefficientType_single_index::
~ZernikeCoefficientType_single_index ()
{
}

// ZernikeSurfaceType
//

ZernikeSurfaceType::
ZernikeSurfaceType ()
: ::xml_schema::type (),
  ZernikeCoefficient_ (this),
  ZernikeCoefficientSingleIndex_ (this)
{
}

ZernikeSurfaceType::
ZernikeSurfaceType (const ZernikeSurfaceType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ZernikeCoefficient_ (x.ZernikeCoefficient_, f, this),
  ZernikeCoefficientSingleIndex_ (x.ZernikeCoefficientSingleIndex_, f, this)
{
}

ZernikeSurfaceType::
ZernikeSurfaceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ZernikeCoefficient_ (this),
  ZernikeCoefficientSingleIndex_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ZernikeSurfaceType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ZernikeCoefficient
    //
    if (n.name () == "ZernikeCoefficient" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ZernikeCoefficient_type > r (
        ZernikeCoefficient_traits::create (i, f, this));

      this->ZernikeCoefficient_.push_back (r);
      continue;
    }

    // ZernikeCoefficientSingleIndex
    //
    if (n.name () == "ZernikeCoefficientSingleIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ZernikeCoefficientSingleIndex_type > r (
        ZernikeCoefficientSingleIndex_traits::create (i, f, this));

      this->ZernikeCoefficientSingleIndex_.push_back (r);
      continue;
    }

    break;
  }
}

ZernikeSurfaceType* ZernikeSurfaceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ZernikeSurfaceType (*this, f, c);
}

ZernikeSurfaceType& ZernikeSurfaceType::
operator= (const ZernikeSurfaceType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ZernikeCoefficient_ = x.ZernikeCoefficient_;
    this->ZernikeCoefficientSingleIndex_ = x.ZernikeCoefficientSingleIndex_;
  }

  return *this;
}

ZernikeSurfaceType::
~ZernikeSurfaceType ()
{
}

// MeshCriteriaGlobalType
//

MeshCriteriaGlobalType::
MeshCriteriaGlobalType (const facet_angle_type& facet_angle,
                        const facet_size_type& facet_size,
                        const facet_distance_type& facet_distance,
                        const cell_radius_edge_ratio_type& cell_radius_edge_ratio,
                        const cell_size_type& cell_size)
: ::xml_schema::type (),
  facet_angle_ (facet_angle, this),
  facet_size_ (facet_size, this),
  facet_distance_ (facet_distance, this),
  cell_radius_edge_ratio_ (cell_radius_edge_ratio, this),
  cell_size_ (cell_size, this)
{
}

MeshCriteriaGlobalType::
MeshCriteriaGlobalType (const MeshCriteriaGlobalType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  facet_angle_ (x.facet_angle_, f, this),
  facet_size_ (x.facet_size_, f, this),
  facet_distance_ (x.facet_distance_, f, this),
  cell_radius_edge_ratio_ (x.cell_radius_edge_ratio_, f, this),
  cell_size_ (x.cell_size_, f, this)
{
}

MeshCriteriaGlobalType::
MeshCriteriaGlobalType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  facet_angle_ (this),
  facet_size_ (this),
  facet_distance_ (this),
  cell_radius_edge_ratio_ (this),
  cell_size_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void MeshCriteriaGlobalType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "facet_angle" && n.namespace_ ().empty ())
    {
      this->facet_angle_.set (facet_angle_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "facet_size" && n.namespace_ ().empty ())
    {
      this->facet_size_.set (facet_size_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "facet_distance" && n.namespace_ ().empty ())
    {
      this->facet_distance_.set (facet_distance_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "cell_radius_edge_ratio" && n.namespace_ ().empty ())
    {
      this->cell_radius_edge_ratio_.set (cell_radius_edge_ratio_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "cell_size" && n.namespace_ ().empty ())
    {
      this->cell_size_.set (cell_size_traits::create (i, f, this));
      continue;
    }
  }

  if (!facet_angle_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "facet_angle",
      "");
  }

  if (!facet_size_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "facet_size",
      "");
  }

  if (!facet_distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "facet_distance",
      "");
  }

  if (!cell_radius_edge_ratio_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cell_radius_edge_ratio",
      "");
  }

  if (!cell_size_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cell_size",
      "");
  }
}

MeshCriteriaGlobalType* MeshCriteriaGlobalType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MeshCriteriaGlobalType (*this, f, c);
}

MeshCriteriaGlobalType& MeshCriteriaGlobalType::
operator= (const MeshCriteriaGlobalType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->facet_angle_ = x.facet_angle_;
    this->facet_size_ = x.facet_size_;
    this->facet_distance_ = x.facet_distance_;
    this->cell_radius_edge_ratio_ = x.cell_radius_edge_ratio_;
    this->cell_size_ = x.cell_size_;
  }

  return *this;
}

MeshCriteriaGlobalType::
~MeshCriteriaGlobalType ()
{
}

// CorneaGenerationCriteriaGlobalType
//

CorneaGenerationCriteriaGlobalType::
CorneaGenerationCriteriaGlobalType (const max_number_zernike_coeffs_type& max_number_zernike_coeffs,
                                    const surface_thickness_type& surface_thickness,
                                    const offset_along_z_type& offset_along_z,
                                    const path_to_output_type& path_to_output)
: ::xml_schema::type (),
  max_number_zernike_coeffs_ (max_number_zernike_coeffs, this),
  surface_thickness_ (surface_thickness, this),
  offset_along_z_ (offset_along_z, this),
  path_to_output_ (path_to_output, this)
{
}

CorneaGenerationCriteriaGlobalType::
CorneaGenerationCriteriaGlobalType (const CorneaGenerationCriteriaGlobalType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  max_number_zernike_coeffs_ (x.max_number_zernike_coeffs_, f, this),
  surface_thickness_ (x.surface_thickness_, f, this),
  offset_along_z_ (x.offset_along_z_, f, this),
  path_to_output_ (x.path_to_output_, f, this)
{
}

CorneaGenerationCriteriaGlobalType::
CorneaGenerationCriteriaGlobalType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  max_number_zernike_coeffs_ (this),
  surface_thickness_ (this),
  offset_along_z_ (this),
  path_to_output_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void CorneaGenerationCriteriaGlobalType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "max_number_zernike_coeffs" && n.namespace_ ().empty ())
    {
      this->max_number_zernike_coeffs_.set (max_number_zernike_coeffs_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "surface_thickness" && n.namespace_ ().empty ())
    {
      this->surface_thickness_.set (surface_thickness_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "offset_along_z" && n.namespace_ ().empty ())
    {
      this->offset_along_z_.set (offset_along_z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "path_to_output" && n.namespace_ ().empty ())
    {
      this->path_to_output_.set (path_to_output_traits::create (i, f, this));
      continue;
    }
  }

  if (!max_number_zernike_coeffs_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "max_number_zernike_coeffs",
      "");
  }

  if (!surface_thickness_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "surface_thickness",
      "");
  }

  if (!offset_along_z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "offset_along_z",
      "");
  }

  if (!path_to_output_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "path_to_output",
      "");
  }
}

CorneaGenerationCriteriaGlobalType* CorneaGenerationCriteriaGlobalType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CorneaGenerationCriteriaGlobalType (*this, f, c);
}

CorneaGenerationCriteriaGlobalType& CorneaGenerationCriteriaGlobalType::
operator= (const CorneaGenerationCriteriaGlobalType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->max_number_zernike_coeffs_ = x.max_number_zernike_coeffs_;
    this->surface_thickness_ = x.surface_thickness_;
    this->offset_along_z_ = x.offset_along_z_;
    this->path_to_output_ = x.path_to_output_;
  }

  return *this;
}

CorneaGenerationCriteriaGlobalType::
~CorneaGenerationCriteriaGlobalType ()
{
}

// LenticuleGenerationCriteriaGlobalType
//

LenticuleGenerationCriteriaGlobalType::
LenticuleGenerationCriteriaGlobalType (const max_number_zernike_coeffs_type& max_number_zernike_coeffs,
                                       const lenticule_radius_type& lenticule_radius,
                                       const cap_thickness_type& cap_thickness,
                                       const lenticule_thickness_type& lenticule_thickness,
                                       const lenticule_surface_distance_type& lenticule_surface_distance)
: ::xml_schema::type (),
  max_number_zernike_coeffs_ (max_number_zernike_coeffs, this),
  lenticule_radius_ (lenticule_radius, this),
  cap_thickness_ (cap_thickness, this),
  lenticule_thickness_ (lenticule_thickness, this),
  lenticule_surface_distance_ (lenticule_surface_distance, this)
{
}

LenticuleGenerationCriteriaGlobalType::
LenticuleGenerationCriteriaGlobalType (const LenticuleGenerationCriteriaGlobalType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  max_number_zernike_coeffs_ (x.max_number_zernike_coeffs_, f, this),
  lenticule_radius_ (x.lenticule_radius_, f, this),
  cap_thickness_ (x.cap_thickness_, f, this),
  lenticule_thickness_ (x.lenticule_thickness_, f, this),
  lenticule_surface_distance_ (x.lenticule_surface_distance_, f, this)
{
}

LenticuleGenerationCriteriaGlobalType::
LenticuleGenerationCriteriaGlobalType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  max_number_zernike_coeffs_ (this),
  lenticule_radius_ (this),
  cap_thickness_ (this),
  lenticule_thickness_ (this),
  lenticule_surface_distance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void LenticuleGenerationCriteriaGlobalType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "max_number_zernike_coeffs" && n.namespace_ ().empty ())
    {
      this->max_number_zernike_coeffs_.set (max_number_zernike_coeffs_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lenticule_radius" && n.namespace_ ().empty ())
    {
      this->lenticule_radius_.set (lenticule_radius_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "cap_thickness" && n.namespace_ ().empty ())
    {
      this->cap_thickness_.set (cap_thickness_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lenticule_thickness" && n.namespace_ ().empty ())
    {
      this->lenticule_thickness_.set (lenticule_thickness_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lenticule_surface_distance" && n.namespace_ ().empty ())
    {
      this->lenticule_surface_distance_.set (lenticule_surface_distance_traits::create (i, f, this));
      continue;
    }
  }

  if (!max_number_zernike_coeffs_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "max_number_zernike_coeffs",
      "");
  }

  if (!lenticule_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "lenticule_radius",
      "");
  }

  if (!cap_thickness_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cap_thickness",
      "");
  }

  if (!lenticule_thickness_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "lenticule_thickness",
      "");
  }

  if (!lenticule_surface_distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "lenticule_surface_distance",
      "");
  }
}

LenticuleGenerationCriteriaGlobalType* LenticuleGenerationCriteriaGlobalType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LenticuleGenerationCriteriaGlobalType (*this, f, c);
}

LenticuleGenerationCriteriaGlobalType& LenticuleGenerationCriteriaGlobalType::
operator= (const LenticuleGenerationCriteriaGlobalType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->max_number_zernike_coeffs_ = x.max_number_zernike_coeffs_;
    this->lenticule_radius_ = x.lenticule_radius_;
    this->cap_thickness_ = x.cap_thickness_;
    this->lenticule_thickness_ = x.lenticule_thickness_;
    this->lenticule_surface_distance_ = x.lenticule_surface_distance_;
  }

  return *this;
}

LenticuleGenerationCriteriaGlobalType::
~LenticuleGenerationCriteriaGlobalType ()
{
}

// ConeBoundaryType
//

ConeBoundaryType::
ConeBoundaryType (const angle_type& angle)
: ::xml_schema::type (),
  angle_ (angle, this)
{
}

ConeBoundaryType::
ConeBoundaryType (const ConeBoundaryType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  angle_ (x.angle_, f, this)
{
}

ConeBoundaryType::
ConeBoundaryType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  angle_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ConeBoundaryType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "angle" && n.namespace_ ().empty ())
    {
      this->angle_.set (angle_traits::create (i, f, this));
      continue;
    }
  }

  if (!angle_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "angle",
      "");
  }
}

ConeBoundaryType* ConeBoundaryType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ConeBoundaryType (*this, f, c);
}

ConeBoundaryType& ConeBoundaryType::
operator= (const ConeBoundaryType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->angle_ = x.angle_;
  }

  return *this;
}

ConeBoundaryType::
~ConeBoundaryType ()
{
}

// CylinderBoundaryType
//

CylinderBoundaryType::
CylinderBoundaryType (const radius_type& radius)
: ::xml_schema::type (),
  radius_ (radius, this)
{
}

CylinderBoundaryType::
CylinderBoundaryType (const CylinderBoundaryType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  radius_ (x.radius_, f, this)
{
}

CylinderBoundaryType::
CylinderBoundaryType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void CylinderBoundaryType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      this->radius_.set (radius_traits::create (i, f, this));
      continue;
    }
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "radius",
      "");
  }
}

CylinderBoundaryType* CylinderBoundaryType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CylinderBoundaryType (*this, f, c);
}

CylinderBoundaryType& CylinderBoundaryType::
operator= (const CylinderBoundaryType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->radius_ = x.radius_;
  }

  return *this;
}

CylinderBoundaryType::
~CylinderBoundaryType ()
{
}

// CorneaBoundaryType
//

CorneaBoundaryType::
CorneaBoundaryType ()
: ::xml_schema::type (),
  Cone_ (this),
  Cylinder_ (this)
{
}

CorneaBoundaryType::
CorneaBoundaryType (const CorneaBoundaryType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Cone_ (x.Cone_, f, this),
  Cylinder_ (x.Cylinder_, f, this)
{
}

CorneaBoundaryType::
CorneaBoundaryType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Cone_ (this),
  Cylinder_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CorneaBoundaryType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Cone
    //
    if (n.name () == "Cone" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cone_type > r (
        Cone_traits::create (i, f, this));

      if (!this->Cone_)
      {
        this->Cone_.set (r);
        continue;
      }
    }

    // Cylinder
    //
    if (n.name () == "Cylinder" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cylinder_type > r (
        Cylinder_traits::create (i, f, this));

      if (!this->Cylinder_)
      {
        this->Cylinder_.set (r);
        continue;
      }
    }

    break;
  }
}

CorneaBoundaryType* CorneaBoundaryType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CorneaBoundaryType (*this, f, c);
}

CorneaBoundaryType& CorneaBoundaryType::
operator= (const CorneaBoundaryType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Cone_ = x.Cone_;
    this->Cylinder_ = x.Cylinder_;
  }

  return *this;
}

CorneaBoundaryType::
~CorneaBoundaryType ()
{
}

// CorneaMeshingParametersType
//

CorneaMeshingParametersType::
CorneaMeshingParametersType (const AnteriorSurface_type& AnteriorSurface,
                             const PosteriorSurface_type& PosteriorSurface,
                             const PupilRadius_type& PupilRadius,
                             const SurfaceDistance_type& SurfaceDistance,
                             const MeshCriteria_type& MeshCriteria,
                             const CorneaGenerationCriteria_type& CorneaGenerationCriteria,
                             const CorneaBoundary_type& CorneaBoundary)
: ::xml_schema::type (),
  AnteriorSurface_ (AnteriorSurface, this),
  PosteriorSurface_ (PosteriorSurface, this),
  PosteriorSurfaceLenticule_ (this),
  PupilRadius_ (PupilRadius, this),
  SurfaceDistance_ (SurfaceDistance, this),
  MeshCriteria_ (MeshCriteria, this),
  CorneaGenerationCriteria_ (CorneaGenerationCriteria, this),
  LenticuleGenerationCriteria_ (this),
  CorneaBoundary_ (CorneaBoundary, this)
{
}

CorneaMeshingParametersType::
CorneaMeshingParametersType (::std::auto_ptr< AnteriorSurface_type > AnteriorSurface,
                             ::std::auto_ptr< PosteriorSurface_type > PosteriorSurface,
                             const PupilRadius_type& PupilRadius,
                             const SurfaceDistance_type& SurfaceDistance,
                             ::std::auto_ptr< MeshCriteria_type > MeshCriteria,
                             ::std::auto_ptr< CorneaGenerationCriteria_type > CorneaGenerationCriteria,
                             ::std::auto_ptr< CorneaBoundary_type > CorneaBoundary)
: ::xml_schema::type (),
  AnteriorSurface_ (AnteriorSurface, this),
  PosteriorSurface_ (PosteriorSurface, this),
  PosteriorSurfaceLenticule_ (this),
  PupilRadius_ (PupilRadius, this),
  SurfaceDistance_ (SurfaceDistance, this),
  MeshCriteria_ (MeshCriteria, this),
  CorneaGenerationCriteria_ (CorneaGenerationCriteria, this),
  LenticuleGenerationCriteria_ (this),
  CorneaBoundary_ (CorneaBoundary, this)
{
}

CorneaMeshingParametersType::
CorneaMeshingParametersType (const CorneaMeshingParametersType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AnteriorSurface_ (x.AnteriorSurface_, f, this),
  PosteriorSurface_ (x.PosteriorSurface_, f, this),
  PosteriorSurfaceLenticule_ (x.PosteriorSurfaceLenticule_, f, this),
  PupilRadius_ (x.PupilRadius_, f, this),
  SurfaceDistance_ (x.SurfaceDistance_, f, this),
  MeshCriteria_ (x.MeshCriteria_, f, this),
  CorneaGenerationCriteria_ (x.CorneaGenerationCriteria_, f, this),
  LenticuleGenerationCriteria_ (x.LenticuleGenerationCriteria_, f, this),
  CorneaBoundary_ (x.CorneaBoundary_, f, this)
{
}

CorneaMeshingParametersType::
CorneaMeshingParametersType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AnteriorSurface_ (this),
  PosteriorSurface_ (this),
  PosteriorSurfaceLenticule_ (this),
  PupilRadius_ (this),
  SurfaceDistance_ (this),
  MeshCriteria_ (this),
  CorneaGenerationCriteria_ (this),
  LenticuleGenerationCriteria_ (this),
  CorneaBoundary_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CorneaMeshingParametersType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AnteriorSurface
    //
    if (n.name () == "AnteriorSurface" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AnteriorSurface_type > r (
        AnteriorSurface_traits::create (i, f, this));

      if (!AnteriorSurface_.present ())
      {
        this->AnteriorSurface_.set (r);
        continue;
      }
    }

    // PosteriorSurface
    //
    if (n.name () == "PosteriorSurface" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PosteriorSurface_type > r (
        PosteriorSurface_traits::create (i, f, this));

      if (!PosteriorSurface_.present ())
      {
        this->PosteriorSurface_.set (r);
        continue;
      }
    }

    // PosteriorSurfaceLenticule
    //
    if (n.name () == "PosteriorSurfaceLenticule" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PosteriorSurfaceLenticule_type > r (
        PosteriorSurfaceLenticule_traits::create (i, f, this));

      if (!this->PosteriorSurfaceLenticule_)
      {
        this->PosteriorSurfaceLenticule_.set (r);
        continue;
      }
    }

    // PupilRadius
    //
    if (n.name () == "PupilRadius" && n.namespace_ ().empty ())
    {
      if (!PupilRadius_.present ())
      {
        this->PupilRadius_.set (PupilRadius_traits::create (i, f, this));
        continue;
      }
    }

    // SurfaceDistance
    //
    if (n.name () == "SurfaceDistance" && n.namespace_ ().empty ())
    {
      if (!SurfaceDistance_.present ())
      {
        this->SurfaceDistance_.set (SurfaceDistance_traits::create (i, f, this));
        continue;
      }
    }

    // MeshCriteria
    //
    if (n.name () == "MeshCriteria" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MeshCriteria_type > r (
        MeshCriteria_traits::create (i, f, this));

      if (!MeshCriteria_.present ())
      {
        this->MeshCriteria_.set (r);
        continue;
      }
    }

    // CorneaGenerationCriteria
    //
    if (n.name () == "CorneaGenerationCriteria" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CorneaGenerationCriteria_type > r (
        CorneaGenerationCriteria_traits::create (i, f, this));

      if (!CorneaGenerationCriteria_.present ())
      {
        this->CorneaGenerationCriteria_.set (r);
        continue;
      }
    }

    // LenticuleGenerationCriteria
    //
    if (n.name () == "LenticuleGenerationCriteria" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LenticuleGenerationCriteria_type > r (
        LenticuleGenerationCriteria_traits::create (i, f, this));

      if (!this->LenticuleGenerationCriteria_)
      {
        this->LenticuleGenerationCriteria_.set (r);
        continue;
      }
    }

    // CorneaBoundary
    //
    if (n.name () == "CorneaBoundary" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CorneaBoundary_type > r (
        CorneaBoundary_traits::create (i, f, this));

      if (!CorneaBoundary_.present ())
      {
        this->CorneaBoundary_.set (r);
        continue;
      }
    }

    break;
  }

  if (!AnteriorSurface_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AnteriorSurface",
      "");
  }

  if (!PosteriorSurface_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PosteriorSurface",
      "");
  }

  if (!PupilRadius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PupilRadius",
      "");
  }

  if (!SurfaceDistance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SurfaceDistance",
      "");
  }

  if (!MeshCriteria_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "MeshCriteria",
      "");
  }

  if (!CorneaGenerationCriteria_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CorneaGenerationCriteria",
      "");
  }

  if (!CorneaBoundary_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CorneaBoundary",
      "");
  }
}

CorneaMeshingParametersType* CorneaMeshingParametersType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CorneaMeshingParametersType (*this, f, c);
}

CorneaMeshingParametersType& CorneaMeshingParametersType::
operator= (const CorneaMeshingParametersType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->AnteriorSurface_ = x.AnteriorSurface_;
    this->PosteriorSurface_ = x.PosteriorSurface_;
    this->PosteriorSurfaceLenticule_ = x.PosteriorSurfaceLenticule_;
    this->PupilRadius_ = x.PupilRadius_;
    this->SurfaceDistance_ = x.SurfaceDistance_;
    this->MeshCriteria_ = x.MeshCriteria_;
    this->CorneaGenerationCriteria_ = x.CorneaGenerationCriteria_;
    this->LenticuleGenerationCriteria_ = x.LenticuleGenerationCriteria_;
    this->CorneaBoundary_ = x.CorneaBoundary_;
  }

  return *this;
}

CorneaMeshingParametersType::
~CorneaMeshingParametersType ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CorneaMeshingParametersType > (
    ::CorneaMeshingParameters (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CorneaMeshingParametersType > (
    ::CorneaMeshingParameters (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CorneaMeshingParametersType > (
    ::CorneaMeshingParameters (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CorneaMeshingParameters (isrc, f, p);
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CorneaMeshingParameters (isrc, h, f, p);
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CorneaMeshingParameters (isrc, h, f, p);
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CorneaMeshingParameters (isrc, f, p);
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CorneaMeshingParameters (isrc, h, f, p);
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CorneaMeshingParameters (isrc, h, f, p);
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CorneaMeshingParametersType > (
    ::CorneaMeshingParameters (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CorneaMeshingParametersType > (
    ::CorneaMeshingParameters (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CorneaMeshingParametersType > (
    ::CorneaMeshingParameters (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (const ::xercesc::DOMDocument& doc,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::CorneaMeshingParametersType > (
      ::CorneaMeshingParameters (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "CorneaMeshingParameters" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::CorneaMeshingParametersType > r (
      ::xsd::cxx::tree::traits< ::CorneaMeshingParametersType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CorneaMeshingParameters",
    "");
}

::std::auto_ptr< ::CorneaMeshingParametersType >
CorneaMeshingParameters (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "CorneaMeshingParameters" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::CorneaMeshingParametersType > r (
      ::xsd::cxx::tree::traits< ::CorneaMeshingParametersType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CorneaMeshingParameters",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

